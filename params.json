{"name":"QuickEggBreaker (Corona -> Marmalade port)","tagline":"Example project for recompiling Corona source directly to Marmalade Quick","body":"I was recently asked “how easy would it be to port a game from Corona to Marmalade”. I wasn't really sure... So I did some porting!\r\n\r\n\r\n#Why port to Marmalade?#\r\n\r\nBoth SDKs support iOS and Android deployments, but Marmalade adds support for:\r\n- Windows Phone, BlackBerry 10, Mac OS X, Windows Desktop, Windows Store, Roku and LG TV platforms\r\n- Open source engine internals (Lua and C++ components) using the popular Cocos2d-x framework. If a feature can be done in Cocos2d then Quick can be made to support it.\r\n- Access to Marmalade’s huge 3rd party ecosystem: Game services, cross-promotion, cloud services, advertisements, cross-platform billing, your own custom integrations…\r\n- The ability to build locally (Corona builds remotely), including local iOS builds on a Windows PC.\r\n\r\n\r\n#Similar looking beasts with very different insides#\r\n\r\nMarmalade Quick is a set of tools and an open source engine that sits on top of the regular Marmalade C++ SDK. Marmalade Quick and Corona share a lot of similarities: both are 2D, use Lua for the language, have a scene graph with nodes/objects that are sprites, polygons or text and use Box2D for physics. They have similar, though far from identical, API signatures as well, plus a lot of similar libraries and types. However, they also have a lot of differences under the hood and each has features that the other does not support out of the box.\r\n\r\nAlthough some core libraries have different names and the mechanics vary, some libraries are very similar and the majority of parameters are identical. I would expect around 30-60% of an app’s code to work without changes. Brute force porting from Corona to Quick would therefore be a case of replacing any non matching calls and types with the Quick equivalent, plus changing coordinate values (see below) and filling any API gaps.\r\n\r\nPorting any app from Corona to Quick should ultimately be possible: a user could provide an implementation of any currently unsupported Corona feature in Quick since Quick can be extended to access all core Marmalade APIs, which can themselves be extended to support most platform capabilities (via the C++ Extensions Development Kit). Going from Quick to Corona ought to be similar for the core Quick API, but not beyond that since Corona’s libraries and build system are closed.\r\n\r\n\r\n#Some challenges#\r\n\r\n**Scene and object libraries:** Corona uses a library called Display which creates DisplayObjects - visual or container nodes used to create a 2D scene graph. Originally there was no higher level component to manage scenes and resources but a popular 3rd party open source library called “Director” was available. Corona then added Storyboards, which was deprecated and replaced with Composer for the same job. In contrast, Marmalade Quick uses an API that handles both creating nodes and managing scenes, also called Director. Quick’s is based on Cocos2d’s Director singleton, which was likely the inspiration for the 3rd party Corona original too.\r\n\r\n**Coordinate spaces:** Corona’s coordinate system has the origin at the top left with Y axis going down the screen. Quick matches Cocos2d’s behaviour, with origin at bottom left and Y going up.\r\n\r\n**Functions vs properties:** Some values are got and set via function calls in one API and by property read/assignment in the other.\r\n\r\n**Events and parameters:** Some events are system ones in one API and related to a node/object in the other or vice versa. Corona accepts a “params” parameter to event registration functions so that user-data can be passed back to event handlers; Quick does not support this. Event names and signatures vary between SDKs.\r\n\r\n**Bloat in Corona APIs:** Quick condenses some Corona APIs. For example it has just a single Sprite type for image based objects, whereas Corona has Images and Sprites; both of those can be replaced with Quick’s Sprite. Corona has GroupObjects, which are non-visible and the only object that can act as a parent for creating trees of display objects, plus Containers, which allow you to apply clipping to any child objects. In Quick any Node object can have children, Nodes themselves can be non-visible and any Node can also have clipping applied to it and it’s children.\r\n\r\n\r\n#Porting a real example#\r\n\r\nI decided to jump straight in and start porting:\r\n\r\n1. I selected an MIT-licensed example from the Corona SDK. I chose Egg Breakers - http://coronalabs.com/sample-apps/egg-breakers - since it is compact but has a good use of key features:\r\n  - A single but sizable main.lua source file, plus a small open source utility library\r\n  - The vanilla Display library to create objects\r\n  - Objects of types: Images, physics, labels, button\r\n  - Global and object events and a timer \r\n1. I pushed the source version to Github: github.com/nickchops/QuickEggBreaker #1\r\n1. I created an empty Marmalade Quick project in the git root folder and moved the original source into the default “resources” folder (NB: you can configure a project to look in any folder to leave the source where it is if needed; I kept it simple for this exercise!)\r\n1. I started porting the code from top down in the games source...\r\n\r\n\r\n#Stop! Brute force porting sucks - Lua can do better...#\r\n\r\nGiven how similar the APIs are, can we do something smarter and more reusable than changing our game code? Yes we can! Since Lua is a flexible language with dynamic types and relatively high performance, we can re-map Corona APIs to quick equivalents by defining or redefining their implementations. A few lines into porting the example, I reverted the changes and switched to this approach so other users can take advantage of my hard work.\r\n\r\n##A working auto-ported example running in Marmalade##\r\nLet’s skip the implementation details for a minute and see the results. After working through the code and creating mappings for all the APIs used, I pushed the final version to the web:\r\n> http://github.com/nickchops/QuickEggBreaker\r\n\r\nGo ahead and import this in Marmalade’s Hub, then run it in the simulator or on any supported device! Note the only very tiny changes made to the original project. The source game is almost identical but a new set of Lua files are responsible for redirecting calls as needed.\r\n\r\n\r\n#Implementing the porting layer#\r\n\r\n##Defining APIs that are new to Quick##\r\n\r\n- First we add source files for any Corona libraries, for example “display.lua” and “physics.lua”. Quick’s files all start with “Q” - e.g. “QPhysics” and are included automatically so there are no potential clashes.\r\nCorona app code must include some libs manually, for example `local physics = require(\"physics\")`. Our one change to our apps source code is to add require calls for libraries that Corona would add automatically - e.g. `require(display)`.\r\n\r\n- Display’s main job is to create DisplayObjects. We can implement it’s creation calls with Quick’s Director, returning the generated Nodes to be used in place of DisplayObjects. Matching functions would then just work. E.g. Corona’s GroupObject can just be a vanilla non-visual Node in Quick, created by adding this to our new display.lua:\r\n```\r\ndisplay = {}\r\n\r\nfunction display.newGroup()\r\n    return director:createNode()\r\nend\r\n```\r\n\r\n- Quick has a “class” that each Node type (node, sprite, label, etc) uses, plus some inherit from each other. The base type is QNode. Since we are using vanilla Nodes above to implement Corona’s groups, we can add implementations of GroupObject functions to the QNode class like this:\r\n```\r\nfunction QNode:removeSelf() -- define Corona interface...\r\n    self:removeFromParent() -- ...using Quick interface\r\nend\r\n\r\nfunction QNode:insert(self, child)\r\n    self:addChild(child)\r\nend\r\n```\r\n\r\n##Overriding existing Quick APIs##\r\nIf a named function exists in Quick but the behaviour needs to change, we can replace or intercept it. All variables in Lua are references that can be reassigned at any time.\r\nExample: Both APIs have audio.loadSound and audio.loadStream. However Corona’s return handles which are passed to a generic `play()` function while Quick stores handles internally but has separate `playSound()` and `playStream()` functions. Our overrides look like this:\r\n```\r\n--keep handle to Quick function\r\naudio.loadSound_orig = audio.loadSound \r\n\r\n--redefine function (takes extra param as well)\r\naudio.loadSound = function(fileName, baseDir)\r\n    if baseDir then fileName = baseDir .. \"/\" .. fileName end\r\n    audio:loadSound_orig(fileName) --call original\r\n    -- original has no return value! so create handle\r\n    local handle = {portType = \"sound\", fileName = fileName}\r\n    return handle\r\nend\r\n\r\naudio.loadStream_orig = audio.loadStream\r\naudio.loadStream = function(fileName, baseDir)\r\n    if baseDir then fileName = baseDir .. \"/\" .. fileName end\r\n    audio:loadStream_orig(fileName)\r\n    local handle = {portType = \"stream\", fileName = fileName}\r\n    return handle\r\nend\r\n\r\nfunction audio.play(handle, options)\r\n    local loop = options.loops\r\n    \r\n    -- use our handle to pick function to call\r\n    if handle.portType == \"stream\" then\r\n        audio:playStream(handle.fileName, loop)\r\n    else\r\n        audio:playSound(handle.fileName, loop)\r\n    end\r\nend\r\n``\r\n\r\n##Fixing our coordinates mismatch##\r\nTo match Corona’s coord system, at the start we just need to flip and move the main y origin, aka the scene itself:\r\n```\r\nquickPorter.scene = director:getCurrentScene()\r\nquickPorter.scene.yScale=-1\r\nquickPorter.scene.y = director.displayHeight\r\n```\r\nThen for some types and features, we need to flip things back in Y. Examples:\r\n- Sprite image direction: Quick has a handy flag for this, so just set `myNode.yFlip = true` inside `display.CreateImage()` etc.\r\n- For physics, we need to reverse the gravity!\r\n```\r\nlocal xGravity,yGravity = physics:getGravity()\r\nphysics:setGravity(xGravity,-yGravity)\r\n\r\n-- plus override physics.getGravity and physics.setGravity!\r\n```\r\n\r\n#Lua Metatables: where the real fun begins!#\r\n\r\nMetatables are Lua’s killer feature. Using them cleverly we can redirect any function or property call on a table to do whatever the hell we want! For example, `myObject.valueA = 27` could be converted to a call to `myOtherObject:setA(27+myObject.offset)`. Hopefully it’s instantly clear that this will be useful in our porter!\r\n\r\n##A quick intro to Metatables##\r\nIn Lua, you can set any table to be the metatable of another table. Whenever the original table has certain actions performed on it, its metatable will be checked for functions with names that correspond to the action, and if the named function is found then it will be called. The actions supported include operators like trying to add or multiply tables, built in functions like `tostring()` and some special keys like `__index`.\r\n\r\nA simple example for the add operator:\r\n```\r\nmyMetatable = {}\r\nmyMetatable.__add = function(v1, v2)\r\n    --do what you want here\r\nend\r\n\r\nmyTable = {}\r\nsetmetatable(myTable, myMetatable)\r\n\r\nmyVar = myTable + 5\r\n--will call the __add function with v1=myTable and v2=5\r\n```\r\n\r\nThe two metatable functions of interest to us are `__index` and `__newindex`. The __index function is called if `myTable.someIndex` is called when someIndex is nil. Note that this includes function calls like `myTable.someFunction()`. __newindex is called if `myTable.someIndex = someValue` is called (an assignment) and someIndex is nil.\r\n\r\n##Using metatables in the porter##\r\nBy having a table with index/newindex functions and setting it as the metatable for each node we create in our wrapper, we can then intercept any call and redirect it. Remember that this only works for indexes that are nil (not just for any index lookup) so we need the “node” itself to be a completely empty table!\r\nUpdating our example from earlier, we make the objects returned to the game code into simple, almost empty tables, with the Quick nodes inside them (I’m using __node as a name that is unlikely to clash with game code!) and then we use display itself as our metatable for convenience:\r\n```\r\nfunction display.newGroup()\r\n    local group = {}\r\n    group.__node = director:createNode()\r\n    setmetatable(group, display)\r\n    return group\r\nend\r\n```\r\nPassing simple tables to the game code, as opposed to Quick Nodes, is a good idea for other reasons: (1) if we tried to set a metatable for an actual Node then things get fiddly since nodes are really userdata types that already have metatables set as part of how classes are implemented in the engine, (2) we avoid having to know anything about Quick’s node object internals or accidentally redefining important indices; the less to touch the Quick nodes directly, the better.\r\n\r\nNow we need to implement the index functions for our display metatable. Note that the “table” param here is the original table, for example “group” in the newGroup function above.\r\n```\r\ndisplay.__index = function (table, key)\r\n    --we can manually override named functions or properties here\r\n    if key == \"someName\" then\r\n        -- do something\r\n    elseif key == \"otherName\" then\r\n        -- do something else\r\n    else\r\n        return table.__node[key] --use the Quick node's value\r\n    end\r\nend\r\n\r\ndisplay.__newindex = function (table, key, value)\r\n    if key == \"someName\" then\r\n        -- do something\r\n        \r\n    else\r\n        node[key] = value --set the nodes value\r\n    end\r\nend\r\n```\r\n\r\n##Directing a property access to a function call##\r\nLet’s look at a real example of redirecting calls with the index functions. In Corona’s physics, you get/set angular velocity via the `myObject.angularVelocity` property. In Quick, we use the `myNode.physics:getAngularVelocity()` function (or its set() equivalent). Note the change from property to function and also the need to call the `.physics` sub-object of the node.\r\n\r\nUsing our `.__index` and `.__newindex` metatable methods, we can intercept the point where that property (table index) get’s accessed and then just call whatever we want:\r\n```\r\ndisplay.__index = function (table, key)\r\n    if key == \"angularVelocity\" then\r\n        return table.__node.physics:getAngularVelocity()\r\n        --etc\r\n\r\ndisplay.__newindex = function (table, key, value)\r\n    if key == \"angularVelocity\" then\r\n        return table.__node.physics:setAngularVelocity(value)\r\n        --etc\r\n```\r\n\r\n#And that’s all we need to know to implement/replace anything!#\r\nI worked top to bottom through my example code, adding wrappers, implementations and metatable overrides as needed. Generally I just did the minimum needed to port this one example app, but in some cases I proactively added handy functions for future projects to use.\r\n\r\n> Check out the finished project here: github.com/nickchops/QuickEggBreaker \r\n\r\n#What’s Next?#\r\nOur example is a great starting point for porting your own project. It could be extended to become a rich porting layer that removes 90%+ of the work for a given title. Currently it only supports a subset of APIs but is easy to extend. A key piece of work is to implement Corona’s director/storyboards/composer functionality if needed (remember not to allow one “director” to replace the other!) What about other Lua toolkits like Moai, Love or Guideros? The porting concepts should work for those too, and once again portability will depend on features needed.\r\n\r\n#Extending Quick to fill feature gaps#\r\nBoth APIs have libraries and features not available in the other. Significant use of unsupported features might mean porting is not appropriate. When porting, be aware that Corona features that do not yet exist in Quick will require adding an implementation to the Lua or C++ source of Quick, or maybe an extension to Marmalade’s abstraction layer, or just removing from your game. Some key ones to bare in mind:\r\n- Corona has a Widgets API for creating skinned or native-looking UIs. Quick currently has no UI/Widgets library. For my example, all I needed was a button so I created a simple button implementation in about 5 minutes. Porting a full UI-based app to Quick would take quite a bit of work as you’d need to build the whole widgets framework.\r\n- Corona has some nice new graphics APIs since the launch of its “Graphics v2” upgrade. I’ve added Quick feature requests for some listed here. Because Quick is built on the open source and rich C++ Cocos2d-x rendering engine, there’s no tech barrier to implementing them, either officially or by enterprising users...\r\n  - Render to texture\r\n  - 2.5D perspective effects using bounding box deformation\r\n  - Built in effects/shaders for node objects\r\n  - Fill and stroke any object: Corona lets you add textures to anything, e.g. add texture to a polygon while Quick separates sprites and solid colour objects\r\n  - Gradient fills\r\n- Overlay scenes: Corona lets you show two scenes at once - this could be synthesised in Quick by just using a single scene with two Nodes instead of two scenes!\r\n\r\n#Useful Links#\r\n- Download Marmalade and get started with Quick: http://madewithmarmalade.com/download\r\n- The GitHub porter project (fork it!): http://github.com/nickchops/QuickEggBreaker\r\n- Use new C++ APIs in Quick: http://madewithmarmalade.com/blog/extending-marmalade-quick\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}